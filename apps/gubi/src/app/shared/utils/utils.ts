import { addMonths, addWeeks } from 'date-fns';
import { iSpaceMember } from '@features/spaces/interfaces/space_member.interface';
import { iUser } from '@features/auth/interfaces/user.interface';

export default class Utils {
  static handleErrorMessage(error: unknown): string {
    if (!error) return '';

    if (typeof error === 'string') {
      return error;
    } else if (error instanceof Error) {
      return error.message;
    }
    return 'An unknown error occurred';
  }

  static adjustDateByMonths(date: Date | string, months: number): Date {
    let refDate = this.toLocalMidnight(date);

    if (typeof date === 'string') {
      const [year, month, day] = date.split('-').map(Number);
      refDate = new Date(year, month - 1, day);
    } else {
      refDate = this.toLocalMidnight(date);
    }

    return addMonths(refDate, months);
  }

  static toLocalMidnight(date: Date | string): Date {
    if (typeof date === 'string') {
      const [year, month, day] = date.split('-').map(Number);
      return new Date(year, month - 1, day);
    } else {
      return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    }
  }

  static addOneWeekToDate(date: Date): Date {
    const refDate = new Date(date);
    return addWeeks(refDate, 1);
  }

  static formatToDateOnly(date: Date | string): string {
    const utcDate = new Date(date);
    return utcDate.toISOString().slice(0, 10);
  }

  /*
   * Formats a date string from 'YYYY-MM-DD' to 'DD-MM-YYYY' or 'YYYY-MM-DD' to Date object
   * @param obj - The object containing the date strings to be formatted
   * @returns The object with formatted date strings
   */
  static formatAllStrToDatePattern(obj: any): any {
    if (obj !== null) {
      for (const key in obj) {
        if (typeof obj[key] === 'string') {
          const dateParts = obj[key].split('-');
          if (dateParts.length === 3) {
            const dateStr = `${dateParts[2]}-${dateParts[1]}-${dateParts[0]}`;
            const formatedDate = dateParts[0].length === 4 ? new Date(obj[key]) : new Date(dateStr);
            obj[key] = this.dateToUTC(formatedDate);
          }
        }
      }
    }
    return obj;
  }

  static dateToUTC(date: Date | string): Date {
    const utcDate = new Date(date);
    utcDate.setMinutes(utcDate.getMinutes() + utcDate.getTimezoneOffset());
    return utcDate;
  }

  static enumToArray(enumObj: any): { label: string; value: number }[] {
    return Object.entries(enumObj)
      .filter(([key, value]) => typeof value === 'number')
      .map(([key, value]) => ({
        label: key,
        value: value as number
      }));
  }

  static groupBy<T>(list: T[], keyGetter: (item: T) => string | number | undefined): { [key: string]: T[] } {
    const map = new Map<string, T[]>();

    list.forEach(item => {
      const key = keyGetter(item);

      if (!key || key === '') {
        return;
      }

      const collection = map.get(key.toString());
      if (collection) {
        collection.push(item);
      } else {
        map.set(key.toString(), [item]);
      }
    });
    return Object.fromEntries(map);
  }

  /*
   * Converts a string to a color code based on its content.
   * The color is generated by hashing the string and limiting the RGB values to avoid very light colors.
   */

  static stringToColor(str: string): string {
    let hash = 0;

    for (let i = 0; i < str.length; i++) {
      hash = str.charCodeAt(i) + ((hash << 5) - hash);
    }

    let color = '#';
    // Defina o valor máximo para cada componente RGB para evitar cores muito claras
    const min = 20; // mínimo para evitar tons muito escuros
    const max = 200; // máximo para evitar tons muito claros

    for (let i = 0; i < 3; i++) {
      let value = (hash >> (i * 8)) & 0xff;
      // Limita o valor entre min e max
      value = Math.max(min, Math.min(max, value));
      color += ('00' + value.toString(16)).slice(-2);
    }

    return color;
  }

  static sortListByProperty<T>(list: T[], property: keyof T, sortOrder: 'asc' | 'desc' = 'asc'): T[] {
    return list.sort((a, b) => {
      if (a[property] < b[property]) {
        return sortOrder == 'asc' ? -1 : 1;
      }
      if (a[property] > b[property]) {
        return sortOrder == 'asc' ? 1 : -1;
      }
      return 0;
    });
  }

  static getDistinctValues<T>(list: T[], property?: keyof T): T[] {
    const seen = new Set();

    if (!Array.isArray(list)) {
      return [];
    }

    return list.filter(item => {
      if (item === null || item === undefined) {
        return false;
      }

      const value = property ? item[property] : item;
      if (seen.has(value)) {
        return false;
      }
      seen.add(value);
      return true;
    });
  }

  static isDateInRange(date: Date, startDate: Date, endDate: Date): boolean {
    return date >= startDate && date <= endDate;
  }

  static getAbbreviatedName(fullName: string | undefined, partsAmount: 1 | 2 | 3 = 2): string {
    if (!fullName) {
      return 'Desconhecido';
    }
    const splited = fullName.split(' ');
    const parts = splited.slice(0, partsAmount);
    return parts.join(' ');
  }

  static normalizeText(text?: string): string {
    if (!text || text == '') return '';
    return text
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[^a-zA-Z0-9]/g, '')
      .toLowerCase();
  }

  static getusersFromMembers(members: iSpaceMember[] | undefined): iUser[] {
    return members?.map(m => m.user) ?? [];
  }

  static get currentMonth() {
    const today = new Date();
    return new Date(today.getUTCFullYear(), today.getUTCMonth(), 1);
  }

  static getAvailablePeriods(): { label: string; value: Date }[] {
    const start = new Date(2025, 0, 1); // Janeiro 2025
    const today = new Date();
    const end = new Date(today.getUTCFullYear(), today.getUTCMonth() + 6, 1); // Seis meses a frente

    const months: { label: string; value: Date }[] = [];

    const iter = new Date(start);
    while (iter <= end) {
      const monthName = iter.toLocaleString('default', { month: 'long' });
      const label = `${monthName} ${iter.getFullYear()}`;
      months.push({
        label: label.charAt(0).toUpperCase() + label.slice(1),
        value: new Date(iter)
      });
      iter.setMonth(iter.getMonth() + 1);
    }
    return months;
  }

  static dateToMonthYearString(date: Date | string): string {
    if (typeof date === 'string') {
      date = new Date(date);
    }
    const monthName = date.toLocaleString('en-US', { month: 'long' });
    return `${monthName}-${date.getFullYear()}`;
  }
}
